


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ProductService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.inventorymanagement.product.service</a>
</div>

<h1>Coverage Summary for Class: ProductService (com.inventorymanagement.product.service)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ProductService</td>
<td class="coverageStat">
  <span class="percent">
    70.6%
  </span>
  <span class="absValue">
    (24/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.4%
  </span>
  <span class="absValue">
    (43/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.9%
  </span>
  <span class="absValue">
    (128/178)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ProductService$$SpringCGLIB$$0</td>
  </tr>
  <tr>
    <td class="name">ProductService$ProductStatistics</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    63.2%
  </span>
  <span class="absValue">
    (24/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.4%
  </span>
  <span class="absValue">
    (43/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.2%
  </span>
  <span class="absValue">
    (128/185)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.inventorymanagement.product.service;
&nbsp;
&nbsp;import com.inventorymanagement.category.model.Category;
&nbsp;import com.inventorymanagement.category.repository.CategoryRepository;
&nbsp;import com.inventorymanagement.common.exception.BusinessException;
&nbsp;import com.inventorymanagement.common.exception.EntityNotFoundException;
&nbsp;import com.inventorymanagement.common.exception.ValidationException;
&nbsp;import com.inventorymanagement.product.model.Product;
&nbsp;import com.inventorymanagement.product.model.ProductDto;
&nbsp;import com.inventorymanagement.product.model.ProductMapper;
&nbsp;import com.inventorymanagement.product.repository.ProductRepository;
&nbsp;import jakarta.transaction.Transactional;
&nbsp;import jakarta.validation.Valid;
&nbsp;import jakarta.validation.constraints.NotNull;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.cache.annotation.CacheEvict;
&nbsp;import org.springframework.cache.annotation.Cacheable;
&nbsp;import org.springframework.data.domain.Page;
&nbsp;import org.springframework.data.domain.Pageable;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.springframework.util.StringUtils;
&nbsp;
&nbsp;/**
&nbsp; * Service class for managing Product entities and business operations. Provides comprehensive
&nbsp; * product management including validation, caching, and business rule enforcement.
&nbsp; */
&nbsp;@Service
&nbsp;@Transactional
&nbsp;public class ProductService {
&nbsp;
<b class="fc">&nbsp;  private static final Logger logger = LoggerFactory.getLogger(ProductService.class);</b>
&nbsp;  private static final String PRODUCT_ENTITY_NAME = &quot;Product&quot;;
&nbsp;
&nbsp;  private final ProductRepository productRepository;
&nbsp;  private final CategoryRepository categoryRepository;
&nbsp;
&nbsp;  @Autowired
&nbsp;  public ProductService(
<b class="fc">&nbsp;      ProductRepository productRepository, CategoryRepository categoryRepository) {</b>
<b class="fc">&nbsp;    this.productRepository = productRepository;</b>
<b class="fc">&nbsp;    this.categoryRepository = categoryRepository;</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== CRUD OPERATIONS =====
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a new product with business rule validation.
&nbsp;   *
&nbsp;   * @param productDto the product data
&nbsp;   * @return the created product DTO
&nbsp;   * @throws ValidationException if validation fails
&nbsp;   * @throws EntityNotFoundException if category not found
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;products&quot;, &quot;productCategories&quot;},
&nbsp;      allEntries = true)
&nbsp;  public ProductDto createProduct(@Valid @NotNull ProductDto productDto) {
<b class="fc">&nbsp;    logger.info(&quot;Creating new product: {}&quot;, productDto.getName());</b>
&nbsp;
&nbsp;    // Trim whitespace from text fields
<b class="fc">&nbsp;    if (productDto.getName() != null) {</b>
<b class="fc">&nbsp;      productDto.setName(productDto.getName().trim());</b>
&nbsp;    }
<b class="fc">&nbsp;    if (productDto.getBrand() != null) {</b>
<b class="fc">&nbsp;      productDto.setBrand(productDto.getBrand().trim());</b>
&nbsp;    }
<b class="fc">&nbsp;    if (productDto.getDescription() != null) {</b>
<b class="fc">&nbsp;      productDto.setDescription(productDto.getDescription().trim());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    validateProductForCreation(productDto);</b>
&nbsp;
<b class="fc">&nbsp;    Product product = ProductMapper.toEntity(productDto);</b>
&nbsp;
&nbsp;    // Set up category relationship
<b class="fc">&nbsp;    Category category = findCategoryById(productDto.getCategoryId());</b>
<b class="fc">&nbsp;    validateCategoryForProduct(category);</b>
<b class="fc">&nbsp;    product.setCategory(category);</b>
&nbsp;
<b class="fc">&nbsp;    Product savedProduct = productRepository.save(product);</b>
&nbsp;
<b class="fc">&nbsp;    logger.info(&quot;Successfully created product with ID: {}&quot;, savedProduct.getId());</b>
<b class="fc">&nbsp;    return ProductMapper.toDto(savedProduct);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Updates an existing product with business rule validation.
&nbsp;   *
&nbsp;   * @param id the product ID
&nbsp;   * @param productDto the updated product data
&nbsp;   * @return the updated product DTO
&nbsp;   * @throws EntityNotFoundException if product not found
&nbsp;   * @throws ValidationException if validation fails
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;products&quot;, &quot;productCategories&quot;},
&nbsp;      allEntries = true)
&nbsp;  public ProductDto updateProduct(@NotNull Long id, @Valid @NotNull ProductDto productDto) {
<b class="fc">&nbsp;    logger.info(&quot;Updating product with ID: {}&quot;, id);</b>
&nbsp;
<b class="fc">&nbsp;    Product existingProduct = findProductById(id);</b>
<b class="fc">&nbsp;    validateProductForUpdate(existingProduct, productDto);</b>
&nbsp;
&nbsp;    // Update basic fields
<b class="fc">&nbsp;    existingProduct.setName(productDto.getName());</b>
<b class="fc">&nbsp;    existingProduct.setDescription(productDto.getDescription());</b>
<b class="fc">&nbsp;    existingProduct.setBrand(productDto.getBrand());</b>
<b class="fc">&nbsp;    existingProduct.setManufacturer(productDto.getManufacturer());</b>
<b class="fc">&nbsp;    existingProduct.setWeight(productDto.getWeight());</b>
<b class="fc">&nbsp;    existingProduct.setDimensions(productDto.getDimensions());</b>
<b class="fc">&nbsp;    existingProduct.setColor(productDto.getColor());</b>
<b class="fc">&nbsp;    existingProduct.setMaterial(productDto.getMaterial());</b>
<b class="fc">&nbsp;    existingProduct.setMetadata(productDto.getMetadata());</b>
&nbsp;
&nbsp;    // Handle category change
<b class="fc">&nbsp;    if (shouldUpdateCategory(existingProduct, productDto)) {</b>
<b class="fc">&nbsp;      Category newCategory = findCategoryById(productDto.getCategoryId());</b>
<b class="fc">&nbsp;      validateCategoryForProduct(newCategory);</b>
<b class="fc">&nbsp;      existingProduct.setCategory(newCategory);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    Product updatedProduct = productRepository.save(existingProduct);</b>
<b class="fc">&nbsp;    logger.info(&quot;Successfully updated product with ID: {}&quot;, id);</b>
&nbsp;
<b class="fc">&nbsp;    return ProductMapper.toDto(updatedProduct);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves a product by ID.
&nbsp;   *
&nbsp;   * @param id the product ID
&nbsp;   * @return the product DTO
&nbsp;   * @throws EntityNotFoundException if product not found
&nbsp;   */
&nbsp;  @Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)
&nbsp;  public ProductDto getProductById(@NotNull Long id) {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving product with ID: {}&quot;, id);</b>
<b class="fc">&nbsp;    Product product = findProductById(id);</b>
<b class="fc">&nbsp;    return ProductMapper.toDto(product);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves all products with pagination.
&nbsp;   *
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; getAllProducts(Pageable pageable) {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving all products with pagination&quot;);</b>
<b class="fc">&nbsp;    Page&lt;Product&gt; products = productRepository.findAllActive(pageable);</b>
<b class="fc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Soft deletes a product.
&nbsp;   *
&nbsp;   * @param id the product ID
&nbsp;   * @throws EntityNotFoundException if product not found
&nbsp;   * @throws BusinessException if product has active SKUs
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;products&quot;, &quot;productCategories&quot;},
&nbsp;      allEntries = true)
&nbsp;  public void deleteProduct(@NotNull Long id) {
<b class="fc">&nbsp;    logger.info(&quot;Deleting product with ID: {}&quot;, id);</b>
&nbsp;
<b class="fc">&nbsp;    Product product = findProductById(id);</b>
<b class="fc">&nbsp;    validateProductForDeletion(product);</b>
&nbsp;
&nbsp;    // Soft delete the product
<b class="fc">&nbsp;    product.markAsDeleted();</b>
<b class="fc">&nbsp;    productRepository.save(product);</b>
&nbsp;
<b class="fc">&nbsp;    logger.info(&quot;Successfully deleted product with ID: {}&quot;, id);</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== CATEGORY-BASED OPERATIONS =====
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves all products in a specific category.
&nbsp;   *
&nbsp;   * @param categoryId the category ID
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of product DTOs
&nbsp;   * @throws EntityNotFoundException if category not found
&nbsp;   */
&nbsp;  @Cacheable(
&nbsp;      value = &quot;productCategories&quot;,
&nbsp;      key = &quot;#categoryId + &#39;:&#39; + #pageable.pageNumber + &#39;:&#39; + #pageable.pageSize&quot;)
&nbsp;  public Page&lt;ProductDto&gt; getProductsByCategory(@NotNull Long categoryId, Pageable pageable) {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving products for category ID: {}&quot;, categoryId);</b>
&nbsp;
&nbsp;    // Verify category exists
<b class="fc">&nbsp;    findCategoryById(categoryId);</b>
&nbsp;
<b class="fc">&nbsp;    Page&lt;Product&gt; products = productRepository.findByCategoryId(categoryId, pageable);</b>
<b class="fc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves all products in categories that match a path pattern (hierarchical).
&nbsp;   *
&nbsp;   * @param categoryPath the category path pattern
&nbsp;   * @return list of product DTOs
&nbsp;   */
&nbsp;  public List&lt;ProductDto&gt; getProductsByCategoryPath(@NotNull String categoryPath) {
<b class="nc">&nbsp;    logger.debug(&quot;Retrieving products for category path: {}&quot;, categoryPath);</b>
&nbsp;
<b class="nc">&nbsp;    if (!StringUtils.hasText(categoryPath)) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;categoryPath&quot;, &quot;Category path cannot be empty&quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    List&lt;Product&gt; products = productRepository.findByCategoryPathStartingWith(categoryPath);</b>
<b class="nc">&nbsp;    return products.stream().map(ProductMapper::toDto).toList();</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== SEARCH AND FILTER OPERATIONS =====
&nbsp;
&nbsp;  /**
&nbsp;   * Searches products by name (case-insensitive partial match).
&nbsp;   *
&nbsp;   * @param name the search term
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of matching product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; searchProductsByName(@NotNull String name, Pageable pageable) {
<b class="nc">&nbsp;    logger.debug(&quot;Searching products by name: {}&quot;, name);</b>
&nbsp;
<b class="nc">&nbsp;    if (!StringUtils.hasText(name)) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;Search term cannot be empty&quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Page&lt;Product&gt; products = productRepository.findByNameContainingIgnoreCase(name, pageable);</b>
<b class="nc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Searches products by brand.
&nbsp;   *
&nbsp;   * @param brand the brand name
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of matching product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; searchProductsByBrand(@NotNull String brand, Pageable pageable) {
<b class="fc">&nbsp;    logger.debug(&quot;Searching products by brand: {}&quot;, brand);</b>
&nbsp;
<b class="pc">&nbsp;    if (!StringUtils.hasText(brand)) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;brand&quot;, &quot;Brand name cannot be empty&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    Page&lt;Product&gt; products = productRepository.findByBrandIgnoreCase(brand, pageable);</b>
<b class="fc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Searches products by manufacturer.
&nbsp;   *
&nbsp;   * @param manufacturer the manufacturer name
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of matching product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; searchProductsByManufacturer(
&nbsp;      @NotNull String manufacturer, Pageable pageable) {
<b class="nc">&nbsp;    logger.debug(&quot;Searching products by manufacturer: {}&quot;, manufacturer);</b>
&nbsp;
<b class="nc">&nbsp;    if (!StringUtils.hasText(manufacturer)) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;manufacturer&quot;, &quot;Manufacturer name cannot be empty&quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Page&lt;Product&gt; products = productRepository.findByManufacturerIgnoreCase(manufacturer, pageable);</b>
<b class="nc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Searches products with multiple criteria.
&nbsp;   *
&nbsp;   * @param searchTerm the search term for name/description (optional)
&nbsp;   * @param brand the brand name (optional)
&nbsp;   * @param categoryId the category ID (optional)
&nbsp;   * @param manufacturer the manufacturer name (optional)
&nbsp;   * @param isActive the active status (optional)
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of matching product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; searchProducts(
&nbsp;      String searchTerm,
&nbsp;      String brand,
&nbsp;      Long categoryId,
&nbsp;      String manufacturer,
&nbsp;      Boolean isActive,
&nbsp;      Pageable pageable) {
<b class="fc">&nbsp;    logger.debug(</b>
&nbsp;        &quot;Searching products with criteria - searchTerm: {}, brand: {}, categoryId: {}, manufacturer: {}, isActive: {}&quot;,
&nbsp;        searchTerm,
&nbsp;        brand,
&nbsp;        categoryId,
&nbsp;        manufacturer,
&nbsp;        isActive);
&nbsp;
<b class="fc">&nbsp;    Page&lt;Product&gt; products =</b>
<b class="fc">&nbsp;        productRepository.findWithFilters(</b>
&nbsp;            searchTerm, categoryId, brand, manufacturer, isActive, pageable);
<b class="fc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Searches products with extended criteria including price range.
&nbsp;   *
&nbsp;   * @param name the search term for name (optional)
&nbsp;   * @param categoryId the category ID (optional)
&nbsp;   * @param brand the brand name (optional)
&nbsp;   * @param manufacturer the manufacturer name (optional)
&nbsp;   * @param minPrice the minimum price (optional)
&nbsp;   * @param maxPrice the maximum price (optional)
&nbsp;   * @param isActive the active status (optional)
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of matching product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; searchProducts(
&nbsp;      String name,
&nbsp;      Long categoryId,
&nbsp;      String brand,
&nbsp;      String manufacturer,
&nbsp;      BigDecimal minPrice,
&nbsp;      BigDecimal maxPrice,
&nbsp;      Boolean isActive,
&nbsp;      Pageable pageable) {
<b class="nc">&nbsp;    logger.debug(</b>
&nbsp;        &quot;Searching products with extended criteria - name: {}, categoryId: {}, brand: {}, manufacturer: {}, minPrice: {}, maxPrice: {}, isActive: {}&quot;,
&nbsp;        name,
&nbsp;        categoryId,
&nbsp;        brand,
&nbsp;        manufacturer,
&nbsp;        minPrice,
&nbsp;        maxPrice,
&nbsp;        isActive);
&nbsp;
<b class="nc">&nbsp;    Page&lt;Product&gt; products =</b>
<b class="nc">&nbsp;        productRepository.findWithExtendedFilters(</b>
&nbsp;            name, categoryId, brand, manufacturer, minPrice, maxPrice, isActive, pageable);
<b class="nc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Searches products by name or description.
&nbsp;   *
&nbsp;   * @param query the search query
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of matching product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; searchProductsByNameOrDescription(
&nbsp;      @NotNull String query, Pageable pageable) {
<b class="fc">&nbsp;    logger.debug(&quot;Searching products by name or description: {}&quot;, query);</b>
&nbsp;
<b class="fc">&nbsp;    if (query == null) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;query&quot;, &quot;search term cannot be null&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Allow empty strings - they should return empty results
<b class="fc">&nbsp;    Page&lt;Product&gt; products =</b>
<b class="fc">&nbsp;        productRepository.findByNameOrDescriptionContainingIgnoreCase(query, pageable);</b>
<b class="fc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves products by brand.
&nbsp;   *
&nbsp;   * @param brand the brand name
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of matching product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; getProductsByBrand(@NotNull String brand, Pageable pageable) {
<b class="nc">&nbsp;    logger.debug(&quot;Retrieving products by brand: {}&quot;, brand);</b>
&nbsp;
<b class="nc">&nbsp;    if (!StringUtils.hasText(brand)) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;brand&quot;, &quot;Brand name cannot be empty&quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Page&lt;Product&gt; products = productRepository.findByBrandIgnoreCase(brand, pageable);</b>
<b class="nc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves products by active status.
&nbsp;   *
&nbsp;   * @param isActive the active status
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; getProductsByStatus(boolean isActive, Pageable pageable) {
<b class="nc">&nbsp;    logger.debug(&quot;Retrieving products by status: {}&quot;, isActive);</b>
<b class="nc">&nbsp;    Page&lt;Product&gt; products = productRepository.findByIsActive(isActive, pageable);</b>
<b class="nc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== BUSINESS LOGIC METHODS =====
&nbsp;
&nbsp;  /**
&nbsp;   * Activates a product.
&nbsp;   *
&nbsp;   * @param id the product ID
&nbsp;   * @throws EntityNotFoundException if product not found
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;products&quot;, &quot;productCategories&quot;},
&nbsp;      allEntries = true)
&nbsp;  public void activateProduct(@NotNull Long id) {
<b class="fc">&nbsp;    logger.info(&quot;Activating product with ID: {}&quot;, id);</b>
&nbsp;
<b class="fc">&nbsp;    Product product = findProductById(id);</b>
&nbsp;
&nbsp;    // Validate that category is active
<b class="pc">&nbsp;    if (!product.getCategory().getIsActive()) {</b>
<b class="nc">&nbsp;      throw new BusinessException(&quot;Cannot activate product in inactive category&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    product.activate();</b>
<b class="fc">&nbsp;    productRepository.save(product);</b>
&nbsp;
<b class="fc">&nbsp;    logger.info(&quot;Successfully activated product with ID: {}&quot;, id);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Deactivates a product.
&nbsp;   *
&nbsp;   * @param id the product ID
&nbsp;   * @throws EntityNotFoundException if product not found
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;products&quot;, &quot;productCategories&quot;},
&nbsp;      allEntries = true)
&nbsp;  public void deactivateProduct(@NotNull Long id) {
<b class="fc">&nbsp;    logger.info(&quot;Deactivating product with ID: {}&quot;, id);</b>
&nbsp;
<b class="fc">&nbsp;    Product product = findProductById(id);</b>
<b class="fc">&nbsp;    product.deactivate(); // This deactivates SKUs as well</b>
<b class="fc">&nbsp;    productRepository.save(product);</b>
&nbsp;
<b class="fc">&nbsp;    logger.info(&quot;Successfully deactivated product with ID: {}&quot;, id);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Moves a product to a different category.
&nbsp;   *
&nbsp;   * @param productId the product ID
&nbsp;   * @param newCategoryId the new category ID
&nbsp;   * @throws EntityNotFoundException if product or category not found
&nbsp;   * @throws BusinessException if category is invalid
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;products&quot;, &quot;productCategories&quot;},
&nbsp;      allEntries = true)
&nbsp;  public void moveProductToCategory(@NotNull Long productId, @NotNull Long newCategoryId) {
<b class="nc">&nbsp;    logger.info(&quot;Moving product {} to category {}&quot;, productId, newCategoryId);</b>
&nbsp;
<b class="nc">&nbsp;    Product product = findProductById(productId);</b>
<b class="nc">&nbsp;    Category newCategory = findCategoryById(newCategoryId);</b>
&nbsp;
<b class="nc">&nbsp;    validateCategoryForProduct(newCategory);</b>
&nbsp;
<b class="nc">&nbsp;    product.setCategory(newCategory);</b>
<b class="nc">&nbsp;    productRepository.save(product);</b>
&nbsp;
<b class="nc">&nbsp;    logger.info(&quot;Successfully moved product {} to category {}&quot;, productId, newCategoryId);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets product statistics for a category.
&nbsp;   *
&nbsp;   * @param categoryId the category ID
&nbsp;   * @return product statistics
&nbsp;   */
&nbsp;  public ProductStatistics getProductStatistics(@NotNull Long categoryId) {
<b class="nc">&nbsp;    logger.debug(&quot;Getting product statistics for category: {}&quot;, categoryId);</b>
&nbsp;
&nbsp;    // Verify category exists
<b class="nc">&nbsp;    findCategoryById(categoryId);</b>
&nbsp;
<b class="nc">&nbsp;    long totalProducts = productRepository.countByCategoryId(categoryId);</b>
<b class="nc">&nbsp;    long activeProducts = productRepository.countActiveByCategoryId(categoryId);</b>
&nbsp;
<b class="nc">&nbsp;    return new ProductStatistics(totalProducts, activeProducts, totalProducts - activeProducts);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets all distinct brands.
&nbsp;   *
&nbsp;   * @return list of distinct brands
&nbsp;   */
&nbsp;  @Cacheable(value = &quot;productBrands&quot;)
&nbsp;  public List&lt;String&gt; getAllBrands() {
<b class="nc">&nbsp;    logger.debug(&quot;Retrieving all distinct brands&quot;);</b>
<b class="nc">&nbsp;    return productRepository.findAllDistinctBrands();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets all distinct manufacturers.
&nbsp;   *
&nbsp;   * @return list of distinct manufacturers
&nbsp;   */
&nbsp;  @Cacheable(value = &quot;productManufacturers&quot;)
&nbsp;  public List&lt;String&gt; getAllManufacturers() {
<b class="nc">&nbsp;    logger.debug(&quot;Retrieving all distinct manufacturers&quot;);</b>
<b class="nc">&nbsp;    return productRepository.findAllDistinctManufacturers();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets all active products with pagination.
&nbsp;   *
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of active product DTOs
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; getActiveProducts(Pageable pageable) {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving all active products with pagination&quot;);</b>
<b class="fc">&nbsp;    Page&lt;Product&gt; products = productRepository.findByIsActive(true, pageable);</b>
<b class="fc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets all products that are low on stock.
&nbsp;   *
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of product DTOs with low stock
&nbsp;   */
&nbsp;  public Page&lt;ProductDto&gt; getLowStockProducts(Pageable pageable) {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving products with low stock&quot;);</b>
<b class="fc">&nbsp;    Page&lt;Product&gt; products = productRepository.findLowStockProducts(pageable);</b>
<b class="fc">&nbsp;    return products.map(ProductMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets all distinct brands.
&nbsp;   *
&nbsp;   * @return list of distinct brands
&nbsp;   */
&nbsp;  @Cacheable(value = &quot;productBrands&quot;)
&nbsp;  public List&lt;String&gt; getDistinctBrands() {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving all distinct brands&quot;);</b>
<b class="fc">&nbsp;    return productRepository.findAllDistinctBrands();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets all distinct manufacturers.
&nbsp;   *
&nbsp;   * @return list of distinct manufacturers
&nbsp;   */
&nbsp;  @Cacheable(value = &quot;productManufacturers&quot;)
&nbsp;  public List&lt;String&gt; getDistinctManufacturers() {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving all distinct manufacturers&quot;);</b>
<b class="fc">&nbsp;    return productRepository.findAllDistinctManufacturers();</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== PRIVATE HELPER METHODS =====
&nbsp;
&nbsp;  private Product findProductById(Long id) {
<b class="fc">&nbsp;    return productRepository</b>
<b class="fc">&nbsp;        .findById(id)</b>
<b class="fc">&nbsp;        .orElseThrow(() -&gt; new EntityNotFoundException(PRODUCT_ENTITY_NAME, id));</b>
&nbsp;  }
&nbsp;
&nbsp;  private Category findCategoryById(Long id) {
<b class="fc">&nbsp;    return categoryRepository</b>
<b class="fc">&nbsp;        .findById(id)</b>
<b class="fc">&nbsp;        .orElseThrow(() -&gt; new EntityNotFoundException(&quot;Category&quot;, id));</b>
&nbsp;  }
&nbsp;
&nbsp;  private void validateProductForCreation(ProductDto productDto) {
<b class="fc">&nbsp;    if (productDto.getName() == null) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;name cannot be null&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    if (!StringUtils.hasText(productDto.getName())) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;cannot be empty&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Validate product name length
<b class="fc">&nbsp;    if (productDto.getName().length() &gt; 255) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;product name too long&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Validate invalid characters in product name
<b class="fc">&nbsp;    if (productDto.getName().matches(&quot;.*[/\\\\|&lt;&gt;].*&quot;)) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;product name contains invalid characters&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Validate brand name length
<b class="fc">&nbsp;    if (productDto.getBrand() != null &amp;&amp; productDto.getBrand().length() &gt; 100) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;brand&quot;, &quot;brand name too long&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Validate description length
<b class="fc">&nbsp;    if (productDto.getDescription() != null &amp;&amp; productDto.getDescription().length() &gt; 5000) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;description&quot;, &quot;description too long&quot;);</b>
&nbsp;    }
&nbsp;
<b class="pc">&nbsp;    if (productDto.getCategoryId() == null) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;categoryId&quot;, &quot;Category is required&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Check for duplicate name in the same category
<b class="fc">&nbsp;    Optional&lt;Product&gt; existing =</b>
<b class="fc">&nbsp;        productRepository.findByNameAndCategoryId(productDto.getName(), productDto.getCategoryId());</b>
<b class="fc">&nbsp;    if (existing.isPresent()) {</b>
<b class="fc">&nbsp;      throw new ValidationException(</b>
&nbsp;          &quot;name&quot;, &quot;Product with this name already exists in the category&quot;);
&nbsp;    }
&nbsp;
&nbsp;    // Validate weight if provided
<b class="pc">&nbsp;    if (productDto.getWeight() != null &amp;&amp; productDto.getWeight().compareTo(BigDecimal.ZERO) &lt; 0) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;weight&quot;, &quot;Weight cannot be negative&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void validateProductForUpdate(Product existingProduct, ProductDto productDto) {
<b class="pc">&nbsp;    if (!StringUtils.hasText(productDto.getName())) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;Product name is required&quot;);</b>
&nbsp;    }
&nbsp;
<b class="pc">&nbsp;    if (productDto.getCategoryId() == null) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;categoryId&quot;, &quot;Category is required&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Check for duplicate name in the same category (excluding current product)
<b class="fc">&nbsp;    boolean nameExists =</b>
<b class="fc">&nbsp;        productRepository.existsByNameAndCategoryIdExcludingId(</b>
<b class="fc">&nbsp;            productDto.getName(), productDto.getCategoryId(), existingProduct.getId());</b>
<b class="fc">&nbsp;    if (nameExists) {</b>
<b class="fc">&nbsp;      throw new ValidationException(</b>
&nbsp;          &quot;name&quot;, &quot;Product with this name already exists in the category&quot;);
&nbsp;    }
&nbsp;
&nbsp;    // Validate weight if provided
<b class="pc">&nbsp;    if (productDto.getWeight() != null &amp;&amp; productDto.getWeight().compareTo(BigDecimal.ZERO) &lt; 0) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;weight&quot;, &quot;Weight cannot be negative&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void validateCategoryForProduct(Category category) {
<b class="fc">&nbsp;    if (!category.getIsActive()) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;categoryId&quot;, &quot;Cannot assign product to inactive category&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Validate category depth - assuming max depth is 10
<b class="fc">&nbsp;    if (category.getLevel() &gt; 10) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;categoryId&quot;, &quot;category depth exceeds maximum allowed level&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void validateProductForDeletion(Product product) {
<b class="fc">&nbsp;    if (product.hasActiveSkus()) {</b>
<b class="fc">&nbsp;      throw new BusinessException(&quot;Cannot delete product with active SKUs&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean shouldUpdateCategory(Product existingProduct, ProductDto productDto) {
<b class="fc">&nbsp;    return !existingProduct.getCategory().getId().equals(productDto.getCategoryId());</b>
&nbsp;  }
&nbsp;
&nbsp;  /** Inner class for product statistics. */
&nbsp;  public static class ProductStatistics {
&nbsp;
&nbsp;    private final long totalProducts;
&nbsp;    private final long activeProducts;
&nbsp;    private final long inactiveProducts;
&nbsp;
<b class="nc">&nbsp;    public ProductStatistics(long totalProducts, long activeProducts, long inactiveProducts) {</b>
<b class="nc">&nbsp;      this.totalProducts = totalProducts;</b>
<b class="nc">&nbsp;      this.activeProducts = activeProducts;</b>
<b class="nc">&nbsp;      this.inactiveProducts = inactiveProducts;</b>
&nbsp;    }
&nbsp;
&nbsp;    public long getTotalProducts() {
<b class="nc">&nbsp;      return totalProducts;</b>
&nbsp;    }
&nbsp;
&nbsp;    public long getActiveProducts() {
<b class="nc">&nbsp;      return activeProducts;</b>
&nbsp;    }
&nbsp;
&nbsp;    public long getInactiveProducts() {
<b class="nc">&nbsp;      return inactiveProducts;</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-07-19 20:52</div>
</div>
</body>
</html>
