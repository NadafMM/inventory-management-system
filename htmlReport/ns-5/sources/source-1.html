


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CategoryService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.inventorymanagement.category.service</a>
</div>

<h1>Coverage Summary for Class: CategoryService (com.inventorymanagement.category.service)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CategoryService</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (21/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67.3%
  </span>
  <span class="absValue">
    (66/98)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68.2%
  </span>
  <span class="absValue">
    (133/195)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CategoryService$$SpringCGLIB$$0</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (21/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67.3%
  </span>
  <span class="absValue">
    (66/98)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68.2%
  </span>
  <span class="absValue">
    (133/195)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.inventorymanagement.category.service;
&nbsp;
&nbsp;import com.inventorymanagement.category.model.Category;
&nbsp;import com.inventorymanagement.category.model.CategoryDto;
&nbsp;import com.inventorymanagement.category.model.CategoryMapper;
&nbsp;import com.inventorymanagement.category.repository.CategoryRepository;
&nbsp;import com.inventorymanagement.common.exception.BusinessException;
&nbsp;import com.inventorymanagement.common.exception.EntityNotFoundException;
&nbsp;import com.inventorymanagement.common.exception.ValidationException;
&nbsp;import jakarta.transaction.Transactional;
&nbsp;import jakarta.validation.Valid;
&nbsp;import jakarta.validation.constraints.NotNull;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.cache.annotation.CacheEvict;
&nbsp;import org.springframework.cache.annotation.Cacheable;
&nbsp;import org.springframework.data.domain.Page;
&nbsp;import org.springframework.data.domain.Pageable;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.springframework.util.StringUtils;
&nbsp;
&nbsp;/**
&nbsp; * Service class for managing Category entities and business operations. Provides comprehensive
&nbsp; * category management including hierarchical operations, validation, and caching.
&nbsp; */
&nbsp;@Service
&nbsp;@Transactional
&nbsp;public class CategoryService {
&nbsp;
<b class="fc">&nbsp;  private static final Logger logger = LoggerFactory.getLogger(CategoryService.class);</b>
&nbsp;  private static final String CATEGORY_ENTITY_NAME = &quot;Category&quot;;
&nbsp;  private static final int MAX_CATEGORY_DEPTH = 10;
&nbsp;
&nbsp;  private final CategoryRepository categoryRepository;
&nbsp;
&nbsp;  @Autowired
<b class="fc">&nbsp;  public CategoryService(CategoryRepository categoryRepository) {</b>
<b class="fc">&nbsp;    this.categoryRepository = categoryRepository;</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== CRUD OPERATIONS =====
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a new category with business rule validation.
&nbsp;   *
&nbsp;   * @param categoryDto the category data
&nbsp;   * @return the created category DTO
&nbsp;   * @throws ValidationException if validation fails
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;categories&quot;, &quot;categoryHierarchy&quot;},
&nbsp;      allEntries = true)
&nbsp;  public CategoryDto createCategory(@Valid @NotNull CategoryDto categoryDto) {
<b class="fc">&nbsp;    logger.info(&quot;Creating new category: {}&quot;, categoryDto.getName());</b>
&nbsp;
&nbsp;    // Trim whitespace from name
<b class="pc">&nbsp;    if (categoryDto.getName() != null) {</b>
<b class="fc">&nbsp;      categoryDto.setName(categoryDto.getName().trim());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    validateCategoryForCreation(categoryDto);</b>
&nbsp;
<b class="fc">&nbsp;    Category category = CategoryMapper.toEntity(categoryDto);</b>
&nbsp;
&nbsp;    // Set up hierarchy if parent is specified
<b class="fc">&nbsp;    if (categoryDto.getParentId() != null) {</b>
<b class="fc">&nbsp;      Category parent = findCategoryById(categoryDto.getParentId());</b>
<b class="fc">&nbsp;      validateParentCategory(parent);</b>
<b class="fc">&nbsp;      setupCategoryHierarchy(category, parent);</b>
&nbsp;    } else {
&nbsp;      // Root category setup
<b class="fc">&nbsp;      category.setLevel(0);</b>
<b class="fc">&nbsp;      category.setPath(&quot;/temp/&quot;); // Temporary path for validation</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    Category savedCategory = categoryRepository.save(category);</b>
&nbsp;
&nbsp;    // Update path after saving to get the ID
<b class="fc">&nbsp;    if (savedCategory.getParent() == null) {</b>
<b class="fc">&nbsp;      savedCategory.setPath(&quot;/&quot; + savedCategory.getId() + &quot;/&quot;);</b>
&nbsp;    } else {
&nbsp;      // Fetch the parent fresh from database to ensure we have the latest path
<b class="fc">&nbsp;      Category parent =</b>
<b class="fc">&nbsp;          categoryRepository.findById(savedCategory.getParent().getId()).orElseThrow();</b>
<b class="fc">&nbsp;      savedCategory.setPath(parent.getPath() + savedCategory.getId() + &quot;/&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    savedCategory = categoryRepository.save(savedCategory);</b>
&nbsp;
<b class="fc">&nbsp;    logger.info(&quot;Successfully created category with ID: {}&quot;, savedCategory.getId());</b>
<b class="fc">&nbsp;    return CategoryMapper.toDto(savedCategory);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Updates an existing category with business rule validation.
&nbsp;   *
&nbsp;   * @param id the category ID
&nbsp;   * @param categoryDto the updated category data
&nbsp;   * @return the updated category DTO
&nbsp;   * @throws EntityNotFoundException if category not found
&nbsp;   * @throws ValidationException if validation fails
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;categories&quot;, &quot;categoryHierarchy&quot;},
&nbsp;      allEntries = true)
&nbsp;  public CategoryDto updateCategory(@NotNull Long id, @Valid @NotNull CategoryDto categoryDto) {
<b class="fc">&nbsp;    logger.info(&quot;Updating category with ID: {}&quot;, id);</b>
&nbsp;
<b class="fc">&nbsp;    Category existingCategory = findCategoryById(id);</b>
<b class="fc">&nbsp;    validateCategoryForUpdate(existingCategory, categoryDto);</b>
&nbsp;
&nbsp;    // Update basic fields - only update non-null fields for partial updates
<b class="pc">&nbsp;    if (categoryDto.getName() != null) {</b>
<b class="fc">&nbsp;      existingCategory.setName(categoryDto.getName());</b>
&nbsp;    }
<b class="fc">&nbsp;    if (categoryDto.getDescription() != null) {</b>
<b class="fc">&nbsp;      existingCategory.setDescription(categoryDto.getDescription());</b>
&nbsp;    }
<b class="fc">&nbsp;    if (categoryDto.getSortOrder() != null) {</b>
<b class="fc">&nbsp;      existingCategory.setSortOrder(categoryDto.getSortOrder());</b>
&nbsp;    }
<b class="pc">&nbsp;    if (categoryDto.getMetadata() != null) {</b>
<b class="nc">&nbsp;      existingCategory.setMetadata(categoryDto.getMetadata());</b>
&nbsp;    }
&nbsp;
&nbsp;    // Handle parent change
<b class="fc">&nbsp;    if (shouldUpdateParent(existingCategory, categoryDto)) {</b>
<b class="fc">&nbsp;      updateCategoryParent(existingCategory, categoryDto.getParentId());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    Category updatedCategory = categoryRepository.save(existingCategory);</b>
<b class="fc">&nbsp;    logger.info(&quot;Successfully updated category with ID: {}&quot;, id);</b>
&nbsp;
<b class="fc">&nbsp;    return CategoryMapper.toDto(updatedCategory);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves a category by ID.
&nbsp;   *
&nbsp;   * @param id the category ID
&nbsp;   * @return the category DTO
&nbsp;   * @throws EntityNotFoundException if category not found
&nbsp;   */
&nbsp;  @Cacheable(value = &quot;categories&quot;, key = &quot;#id&quot;)
&nbsp;  public CategoryDto getCategoryById(@NotNull Long id) {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving category with ID: {}&quot;, id);</b>
<b class="fc">&nbsp;    Category category = findCategoryById(id);</b>
<b class="fc">&nbsp;    return CategoryMapper.toDto(category);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves all categories with pagination.
&nbsp;   *
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of category DTOs
&nbsp;   */
&nbsp;  public Page&lt;CategoryDto&gt; getAllCategories(Pageable pageable) {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving all categories with pagination&quot;);</b>
<b class="fc">&nbsp;    Page&lt;Category&gt; categories = categoryRepository.findAllActive(pageable);</b>
<b class="fc">&nbsp;    return categories.map(CategoryMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Soft deletes a category and all its children.
&nbsp;   *
&nbsp;   * @param id the category ID
&nbsp;   * @throws EntityNotFoundException if category not found
&nbsp;   * @throws BusinessException if category has products
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;categories&quot;, &quot;categoryHierarchy&quot;},
&nbsp;      allEntries = true)
&nbsp;  public void deleteCategory(@NotNull Long id) {
<b class="fc">&nbsp;    logger.info(&quot;Deleting category with ID: {}&quot;, id);</b>
&nbsp;
<b class="fc">&nbsp;    Category category = findCategoryById(id);</b>
<b class="fc">&nbsp;    validateCategoryForDeletion(category);</b>
&nbsp;
&nbsp;    // Soft delete the category and all its children
<b class="fc">&nbsp;    softDeleteCategoryTree(category);</b>
&nbsp;
<b class="fc">&nbsp;    logger.info(&quot;Successfully deleted category with ID: {}&quot;, id);</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== HIERARCHICAL OPERATIONS =====
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves all root categories (categories with no parent).
&nbsp;   *
&nbsp;   * @return list of root category DTOs
&nbsp;   */
&nbsp;  @Cacheable(value = &quot;categoryHierarchy&quot;, key = &quot;&#39;rootCategories&#39;&quot;)
&nbsp;  public List&lt;CategoryDto&gt; getRootCategories() {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving all root categories&quot;);</b>
<b class="fc">&nbsp;    List&lt;Category&gt; rootCategories = categoryRepository.findAllRootCategories();</b>
<b class="fc">&nbsp;    return rootCategories.stream().map(CategoryMapper::toDto).toList();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves all children of a specific category.
&nbsp;   *
&nbsp;   * @param parentId the parent category ID
&nbsp;   * @return list of child category DTOs
&nbsp;   * @throws EntityNotFoundException if parent category not found
&nbsp;   */
&nbsp;  @Cacheable(value = &quot;categoryHierarchy&quot;, key = &quot;&#39;children:&#39; + #parentId&quot;)
&nbsp;  public List&lt;CategoryDto&gt; getChildCategories(@NotNull Long parentId) {
<b class="fc">&nbsp;    logger.debug(&quot;Retrieving children for category ID: {}&quot;, parentId);</b>
&nbsp;
&nbsp;    // Verify parent exists
<b class="fc">&nbsp;    findCategoryById(parentId);</b>
&nbsp;
<b class="fc">&nbsp;    List&lt;Category&gt; children = categoryRepository.findByParentId(parentId);</b>
<b class="fc">&nbsp;    return children.stream().map(CategoryMapper::toDto).toList();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves the complete category path from root to the specified category.
&nbsp;   *
&nbsp;   * @param categoryId the target category ID
&nbsp;   * @return list of category DTOs representing the path
&nbsp;   * @throws EntityNotFoundException if category not found
&nbsp;   */
&nbsp;  @Cacheable(value = &quot;categoryHierarchy&quot;, key = &quot;&#39;path:&#39; + #categoryId&quot;)
&nbsp;  public List&lt;CategoryDto&gt; getCategoryPath(@NotNull Long categoryId) {
<b class="nc">&nbsp;    logger.debug(&quot;Retrieving category path for ID: {}&quot;, categoryId);</b>
&nbsp;
<b class="nc">&nbsp;    Category category = findCategoryById(categoryId);</b>
<b class="nc">&nbsp;    List&lt;Category&gt; pathCategories = categoryRepository.findPathToCategory(categoryId);</b>
&nbsp;
<b class="nc">&nbsp;    return pathCategories.stream().map(CategoryMapper::toDto).toList();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Moves a category to a new parent.
&nbsp;   *
&nbsp;   * @param categoryId the category to move
&nbsp;   * @param newParentId the new parent category ID (null for root)
&nbsp;   * @throws EntityNotFoundException if category or parent not found
&nbsp;   * @throws BusinessException if move would create a cycle
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;categories&quot;, &quot;categoryHierarchy&quot;},
&nbsp;      allEntries = true)
&nbsp;  public void moveCategoryToParent(@NotNull Long categoryId, Long newParentId) {
<b class="nc">&nbsp;    logger.info(&quot;Moving category {} to parent {}&quot;, categoryId, newParentId);</b>
&nbsp;
<b class="nc">&nbsp;    Category category = findCategoryById(categoryId);</b>
&nbsp;
<b class="nc">&nbsp;    if (newParentId != null) {</b>
<b class="nc">&nbsp;      Category newParent = findCategoryById(newParentId);</b>
<b class="nc">&nbsp;      validateCategoryMove(category, newParent);</b>
<b class="nc">&nbsp;      setupCategoryHierarchy(category, newParent);</b>
&nbsp;    } else {
&nbsp;      // Moving to root level
<b class="nc">&nbsp;      category.setParent(null);</b>
<b class="nc">&nbsp;      category.setLevel(0);</b>
<b class="nc">&nbsp;      category.setPath(&quot;/&quot; + category.getId() + &quot;/&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Update all descendant paths
<b class="nc">&nbsp;    updateDescendantPaths(category);</b>
&nbsp;
<b class="nc">&nbsp;    categoryRepository.save(category);</b>
<b class="nc">&nbsp;    logger.info(&quot;Successfully moved category {} to parent {}&quot;, categoryId, newParentId);</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== SEARCH AND FILTER OPERATIONS =====
&nbsp;
&nbsp;  /**
&nbsp;   * Searches categories by name (case-insensitive partial match).
&nbsp;   *
&nbsp;   * @param name the search term
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of matching category DTOs
&nbsp;   */
&nbsp;  public Page&lt;CategoryDto&gt; searchCategoriesByName(@NotNull String name, Pageable pageable) {
<b class="nc">&nbsp;    logger.debug(&quot;Searching categories by name: {}&quot;, name);</b>
&nbsp;
<b class="nc">&nbsp;    if (!StringUtils.hasText(name)) {</b>
<b class="nc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;Search term cannot be empty&quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Page&lt;Category&gt; categories = categoryRepository.findByNameContainingIgnoreCase(name, pageable);</b>
<b class="nc">&nbsp;    return categories.map(CategoryMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves categories by active status.
&nbsp;   *
&nbsp;   * @param isActive the active status
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of category DTOs
&nbsp;   */
&nbsp;  public Page&lt;CategoryDto&gt; getCategoriesByStatus(boolean isActive, Pageable pageable) {
<b class="nc">&nbsp;    logger.debug(&quot;Retrieving categories by status: {}&quot;, isActive);</b>
<b class="nc">&nbsp;    Page&lt;Category&gt; categories = categoryRepository.findByIsActive(isActive, pageable);</b>
<b class="nc">&nbsp;    return categories.map(CategoryMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Searches categories with multiple filter criteria.
&nbsp;   *
&nbsp;   * @param name filter by name (optional)
&nbsp;   * @param parentId filter by parent ID (optional)
&nbsp;   * @param level filter by level (optional)
&nbsp;   * @param isActive filter by active status (optional)
&nbsp;   * @param pageable pagination information
&nbsp;   * @return page of matching category DTOs
&nbsp;   */
&nbsp;  public Page&lt;CategoryDto&gt; searchCategories(
&nbsp;      String name, Long parentId, Integer level, Boolean isActive, Pageable pageable) {
<b class="nc">&nbsp;    logger.debug(</b>
&nbsp;        &quot;Searching categories with filters - name: {}, parentId: {}, level: {}, isActive: {}&quot;,
&nbsp;        name,
&nbsp;        parentId,
&nbsp;        level,
&nbsp;        isActive);
&nbsp;
<b class="nc">&nbsp;    Page&lt;Category&gt; categories =</b>
<b class="nc">&nbsp;        categoryRepository.findWithFilters(name, parentId, level, isActive, pageable);</b>
<b class="nc">&nbsp;    return categories.map(CategoryMapper::toDto);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Retrieves category hierarchy as a tree structure.
&nbsp;   *
&nbsp;   * @param rootId the root category ID (optional, null for all root categories)
&nbsp;   * @return list of category DTOs with hierarchical structure
&nbsp;   */
&nbsp;  @Cacheable(
&nbsp;      value = &quot;categoryHierarchy&quot;,
&nbsp;      key = &quot;&#39;hierarchy:&#39; + (#rootId != null ? #rootId : &#39;all&#39;)&quot;)
&nbsp;  public List&lt;CategoryDto&gt; getCategoryHierarchy(Long rootId) {
<b class="nc">&nbsp;    logger.debug(&quot;Retrieving category hierarchy with root ID: {}&quot;, rootId);</b>
&nbsp;
&nbsp;    List&lt;Category&gt; categories;
<b class="nc">&nbsp;    if (rootId != null) {</b>
&nbsp;      // Get hierarchy starting from specific root
<b class="nc">&nbsp;      Category rootCategory = findCategoryById(rootId);</b>
<b class="nc">&nbsp;      categories = categoryRepository.findAllDescendantsByPath(rootCategory.getPath());</b>
&nbsp;    } else {
&nbsp;      // Get all root categories and their descendants
<b class="nc">&nbsp;      categories = categoryRepository.findAllActiveOrderedByPath();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return categories.stream().map(CategoryMapper::toDto).toList();</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== BUSINESS LOGIC METHODS =====
&nbsp;
&nbsp;  /**
&nbsp;   * Activates a category and optionally its children.
&nbsp;   *
&nbsp;   * @param id the category ID
&nbsp;   * @param includeChildren whether to activate children as well
&nbsp;   * @throws EntityNotFoundException if category not found
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;categories&quot;, &quot;categoryHierarchy&quot;},
&nbsp;      allEntries = true)
&nbsp;  public void activateCategory(@NotNull Long id, boolean includeChildren) {
<b class="nc">&nbsp;    logger.info(&quot;Activating category with ID: {} (includeChildren: {})&quot;, id, includeChildren);</b>
&nbsp;
<b class="nc">&nbsp;    Category category = findCategoryById(id);</b>
<b class="nc">&nbsp;    category.activate();</b>
&nbsp;
<b class="nc">&nbsp;    if (includeChildren) {</b>
<b class="nc">&nbsp;      activateChildrenRecursively(category);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    categoryRepository.save(category);</b>
<b class="nc">&nbsp;    logger.info(&quot;Successfully activated category with ID: {}&quot;, id);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Deactivates a category and all its children.
&nbsp;   *
&nbsp;   * @param id the category ID
&nbsp;   * @throws EntityNotFoundException if category not found
&nbsp;   */
&nbsp;  @CacheEvict(
&nbsp;      value = {&quot;categories&quot;, &quot;categoryHierarchy&quot;},
&nbsp;      allEntries = true)
&nbsp;  public void deactivateCategory(@NotNull Long id) {
<b class="nc">&nbsp;    logger.info(&quot;Deactivating category with ID: {}&quot;, id);</b>
&nbsp;
<b class="nc">&nbsp;    Category category = findCategoryById(id);</b>
<b class="nc">&nbsp;    category.deactivate(); // This deactivates children as well</b>
&nbsp;
<b class="nc">&nbsp;    categoryRepository.save(category);</b>
<b class="nc">&nbsp;    logger.info(&quot;Successfully deactivated category with ID: {}&quot;, id);</b>
&nbsp;  }
&nbsp;
&nbsp;  // ===== PRIVATE HELPER METHODS =====
&nbsp;
&nbsp;  private Category findCategoryById(Long id) {
<b class="fc">&nbsp;    return categoryRepository</b>
<b class="fc">&nbsp;        .findById(id)</b>
<b class="fc">&nbsp;        .orElseThrow(() -&gt; new EntityNotFoundException(CATEGORY_ENTITY_NAME, id));</b>
&nbsp;  }
&nbsp;
&nbsp;  private void validateCategoryForCreation(CategoryDto categoryDto) {
<b class="fc">&nbsp;    if (!StringUtils.hasText(categoryDto.getName())) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;Category name is required&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Validate name length
<b class="fc">&nbsp;    if (categoryDto.getName().length() &gt; 255) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;Category name is too long&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Check for invalid characters
<b class="fc">&nbsp;    if (categoryDto.getName().contains(&quot;&lt;&quot;)</b>
<b class="pc">&nbsp;        || categoryDto.getName().contains(&quot;&gt;&quot;)</b>
<b class="pc">&nbsp;        || categoryDto.getName().contains(&quot;&amp;&quot;)</b>
<b class="pc">&nbsp;        || categoryDto.getName().contains(&quot;\&quot;&quot;)</b>
<b class="pc">&nbsp;        || categoryDto.getName().contains(&quot;&#39;&quot;)</b>
<b class="pc">&nbsp;        || categoryDto.getName().contains(&quot;/&quot;)</b>
<b class="pc">&nbsp;        || categoryDto.getName().contains(&quot;\\&quot;)) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;Category name contains invalid characters&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Validate sort order boundaries
<b class="fc">&nbsp;    if (categoryDto.getSortOrder() != null &amp;&amp; categoryDto.getSortOrder() &lt; 0) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;sortOrder&quot;, &quot;Sort order must be non-negative&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Check for duplicate name at the same level
<b class="fc">&nbsp;    if (categoryDto.getParentId() != null) {</b>
<b class="fc">&nbsp;      Optional&lt;Category&gt; existing =</b>
<b class="fc">&nbsp;          categoryRepository.findByNameAndParentId(</b>
<b class="fc">&nbsp;              categoryDto.getName(), categoryDto.getParentId());</b>
<b class="fc">&nbsp;      if (existing.isPresent()) {</b>
<b class="fc">&nbsp;        throw new ValidationException(&quot;name&quot;, &quot;Category name already exists at this level&quot;);</b>
&nbsp;      }
&nbsp;    } else {
<b class="fc">&nbsp;      Optional&lt;Category&gt; existing = categoryRepository.findRootByName(categoryDto.getName());</b>
<b class="fc">&nbsp;      if (existing.isPresent()) {</b>
<b class="fc">&nbsp;        throw new ValidationException(&quot;name&quot;, &quot;Root category with this name already exists&quot;);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void validateCategoryForUpdate(Category existingCategory, CategoryDto categoryDto) {
<b class="fc">&nbsp;    if (!StringUtils.hasText(categoryDto.getName())) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;name&quot;, &quot;Category name is required&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Check for duplicate name at the same level (excluding current category)
<b class="fc">&nbsp;    if (categoryDto.getParentId() != null) {</b>
<b class="fc">&nbsp;      boolean nameExists =</b>
<b class="fc">&nbsp;          categoryRepository.existsByNameAndParentIdExcludingId(</b>
<b class="fc">&nbsp;              categoryDto.getName(), categoryDto.getParentId(), existingCategory.getId());</b>
<b class="fc">&nbsp;      if (nameExists) {</b>
<b class="fc">&nbsp;        throw new ValidationException(&quot;name&quot;, &quot;Category name already exists at this level&quot;);</b>
&nbsp;      }
&nbsp;    } else {
<b class="fc">&nbsp;      Optional&lt;Category&gt; existing = categoryRepository.findRootByName(categoryDto.getName());</b>
<b class="pc">&nbsp;      if (existing.isPresent() &amp;&amp; !existing.get().getId().equals(existingCategory.getId())) {</b>
<b class="nc">&nbsp;        throw new ValidationException(&quot;name&quot;, &quot;Root category with this name already exists&quot;);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void validateParentCategory(Category parent) {
<b class="pc">&nbsp;    if (!parent.getIsActive()) {</b>
<b class="nc">&nbsp;      throw new BusinessException(&quot;Cannot create category under inactive parent&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (parent.getLevel() &gt;= MAX_CATEGORY_DEPTH) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;parentId&quot;, &quot;Maximum category depth exceeded&quot;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void validateCategoryForDeletion(Category category) {
&nbsp;    // Check for products directly in this category
<b class="fc">&nbsp;    long productCount = categoryRepository.countProductsByCategoryId(category.getId());</b>
<b class="fc">&nbsp;    if (productCount &gt; 0) {</b>
<b class="fc">&nbsp;      throw new BusinessException(&quot;Cannot delete category with existing products&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Check for products in any descendant categories
<b class="fc">&nbsp;    List&lt;Category&gt; descendants = categoryRepository.findAllDescendantsByPath(category.getPath());</b>
<b class="fc">&nbsp;    for (Category descendant : descendants) {</b>
<b class="fc">&nbsp;      if (!descendant.getId().equals(category.getId())) {</b>
<b class="fc">&nbsp;        long descendantProductCount =</b>
<b class="fc">&nbsp;            categoryRepository.countProductsByCategoryId(descendant.getId());</b>
<b class="pc">&nbsp;        if (descendantProductCount &gt; 0) {</b>
<b class="fc">&nbsp;          throw new BusinessException(</b>
&nbsp;              &quot;Cannot delete category with products in descendant categories&quot;);
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void validateCategoryMove(Category category, Category newParent) {
&nbsp;    // Check if trying to set parent as self
<b class="fc">&nbsp;    if (category.getId().equals(newParent.getId())) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;parentId&quot;, &quot;Category cannot be its own parent&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Check if move would create a cycle
<b class="fc">&nbsp;    if (isAncestor(category, newParent)) {</b>
<b class="fc">&nbsp;      throw new ValidationException(&quot;parentId&quot;, &quot;Cannot move category to its own descendant&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    validateParentCategory(newParent);</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isAncestor(Category potentialAncestor, Category category) {
<b class="fc">&nbsp;    Category current = category.getParent();</b>
<b class="fc">&nbsp;    while (current != null) {</b>
<b class="pc">&nbsp;      if (current.getId().equals(potentialAncestor.getId())) {</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;      }
<b class="nc">&nbsp;      current = current.getParent();</b>
&nbsp;    }
<b class="fc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  private void setupCategoryHierarchy(Category category, Category parent) {
<b class="fc">&nbsp;    category.setParent(parent);</b>
<b class="fc">&nbsp;    category.setLevel(parent.getLevel() + 1);</b>
&nbsp;    // Set temporary path for validation, will be updated after saving when we have
&nbsp;    // the ID
<b class="fc">&nbsp;    if (category.getId() != null) {</b>
<b class="fc">&nbsp;      category.setPath(parent.getPath() + category.getId() + &quot;/&quot;);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      category.setPath(&quot;/temp/&quot;); // Temporary path for validation</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private boolean shouldUpdateParent(Category existingCategory, CategoryDto categoryDto) {
&nbsp;    Long currentParentId =
<b class="pc">&nbsp;        existingCategory.getParent() != null ? existingCategory.getParent().getId() : null;</b>
<b class="fc">&nbsp;    return !java.util.Objects.equals(currentParentId, categoryDto.getParentId());</b>
&nbsp;  }
&nbsp;
&nbsp;  private void updateCategoryParent(Category category, Long newParentId) {
<b class="pc">&nbsp;    if (newParentId != null) {</b>
<b class="fc">&nbsp;      Category newParent = findCategoryById(newParentId);</b>
<b class="fc">&nbsp;      validateCategoryMove(category, newParent);</b>
<b class="fc">&nbsp;      setupCategoryHierarchy(category, newParent);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      category.setParent(null);</b>
<b class="nc">&nbsp;      category.setLevel(0);</b>
<b class="nc">&nbsp;      category.setPath(&quot;/&quot; + category.getId() + &quot;/&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    updateDescendantPaths(category);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void updateDescendantPaths(Category category) {
<b class="fc">&nbsp;    List&lt;Category&gt; descendants = categoryRepository.findAllDescendantsByPath(category.getPath());</b>
<b class="pc">&nbsp;    for (Category descendant : descendants) {</b>
<b class="nc">&nbsp;      if (!descendant.getId().equals(category.getId())) {</b>
&nbsp;        // Recalculate path based on parent
<b class="nc">&nbsp;        Category parent = descendant.getParent();</b>
<b class="nc">&nbsp;        if (parent != null) {</b>
<b class="nc">&nbsp;          descendant.setPath(parent.getPath() + descendant.getId() + &quot;/&quot;);</b>
<b class="nc">&nbsp;          descendant.setLevel(parent.getLevel() + 1);</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void softDeleteCategoryTree(Category category) {
<b class="fc">&nbsp;    category.markAsDeleted();</b>
&nbsp;
&nbsp;    // Recursively soft delete all children
<b class="fc">&nbsp;    List&lt;Category&gt; children = categoryRepository.findByParentId(category.getId());</b>
<b class="fc">&nbsp;    for (Category child : children) {</b>
<b class="fc">&nbsp;      softDeleteCategoryTree(child);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void activateChildrenRecursively(Category category) {
<b class="nc">&nbsp;    List&lt;Category&gt; children = categoryRepository.findByParentId(category.getId());</b>
<b class="nc">&nbsp;    for (Category child : children) {</b>
<b class="nc">&nbsp;      child.activate();</b>
<b class="nc">&nbsp;      activateChildrenRecursively(child);</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-07-19 20:52</div>
</div>
</body>
</html>
